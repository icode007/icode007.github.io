<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="web前端,html,css,javascript,vue">
<meta property="og:type" content="website">
<meta property="og:title" content="icode007">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="icode007">
<meta property="og:description" content="web前端,html,css,javascript,vue">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="icode007">
<meta name="twitter:description" content="web前端,html,css,javascript,vue">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>icode007</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">icode007</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">keep studying, keep coding.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/10/es6-函数扩展/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yunlong Li">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/favicon.ico">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="icode007">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/10/es6-函数扩展/" itemprop="url">es6 - 函数的扩展</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-10T21:30:00+08:00">
                2017-04-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="es6-函数的扩展"><a href="#es6-函数的扩展" class="headerlink" title="es6 - 函数的扩展"></a>es6 - 函数的扩展</h1><p>上一篇，我们介绍了es6箭头函数的内容 - <a href="https://segmentfault.com/a/1190000013307378" target="_blank" rel="noopener">es6 - 箭头函数</a>。</p>
<p>事实上，箭头函数只是函数扩展中最有意思的那部分，除此以外，es6函数还增加了一些其他的特性，下面将对它们进行一一介绍。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="es6函数参数的默认值"><a href="#es6函数参数的默认值" class="headerlink" title="es6函数参数的默认值"></a>es6函数参数的默认值</h3><p>在es6之前，我们如果想要设置函数参数的默认值，需要这样写代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function makeRequest(url, timeout, callback)&#123;</span><br><span class="line">    timeout = timeout || 2000;</span><br><span class="line">    callback = callback || function()&#123;&#125;;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>或者更加严谨的写法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">timeout = (typeof timeout !== &apos;undefined&apos;) ? timeout : 2000;</span><br><span class="line">callback = (typeof callback !== &apos;undefined&apos;) ? callback : function()&#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>es6增加了函数参数默认值的特性，可以直接在参数里设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function makeRequest(url, timeout = 2000, callback = function()&#123;&#125;)&#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意：只有在没有传入相应的参数或是传入undefined时，才会使用参数的默认值。</p>
<h3 id="es6剩余参数"><a href="#es6剩余参数" class="headerlink" title="es6剩余参数"></a>es6剩余参数</h3><p>剩余参数由三个点<code>...</code>和一个具名参数指定，比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function pick(object, ...keys)&#123;</span><br><span class="line">    console.log(keys);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个函数内部，剩余参数keys是由传入的第二个参数及以后的参数组成的数组。如果只传入0个或者1个参数，keys为空数组。</p>
<h3 id="扩展运算符…"><a href="#扩展运算符…" class="headerlink" title="扩展运算符…"></a>扩展运算符…</h3><p>扩展运算符有点像是剩余参数的反作用。 我们使用一个场景来说明扩展运算符<code>...</code>该怎么使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function getMax(num1, num2)&#123;</span><br><span class="line">    let result = arguments[0];</span><br><span class="line">    for(var i=0; i&lt;arguments.length; i++)&#123;</span><br><span class="line">        if(arguments[i] &gt; result)&#123;</span><br><span class="line">            result = arguments[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面这个函数大概实现了返回参数中最大值的功能。我们可以这样调用它，<code>getMax(num1, num2, num3, ...)</code>。</p>
<p>可是如果我现在想把一个很大的数组 arr 作为参数传入函数中呢？</p>
<p>或许可以使用apply方法：<code>getMax.apply(null, arr);</code></p>
<p>可是这样实现总感觉不大对劲，使用…能够使得代码意图更加清晰： <code>getMax(...arr)</code>。</p>
<p><code>...</code>运算符能够将arr分割为单独的参数传入函数，它甚至还可以和其他参数一起使用：<br>比如： <code>getMax(num1, ...arr, num2)</code>。代码这样看起来好多了。</p>
<h3 id="函数的名称属性"><a href="#函数的名称属性" class="headerlink" title="函数的名称属性"></a>函数的名称属性</h3><p>es6给所有的函数都添加了name属性，用来根据名称识别函数。匿名函数的name属性的值为空字符串。在实践中，该属性使用很少，不再赘述。</p>
<h3 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h3><p>记得在js语言精粹中介绍递归部分时，作者说，js没有尾调用优化，所以递归可能因为堆栈溢出而运行失败。<br>在es6中，js提供了尾调用优化，什么是尾调用优化？可以参考下面代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function doSomething()&#123;</span><br><span class="line">    return doSomethingElse();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的doSomethingElse函数的调用语句是doSomething的最后一条语句，并作为doSomething返回值返回。上面的函数就实现了尾调用优化。</p>
<p>尾调用优化能够提高函数的性能。它最适合的使用场景是在递归中使用。</p>
<p>在平时的开发中，除非使用递归或者是尽力优化函数的性能，否则无需考虑太多尾递归优化。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li><p>使用剩余参数时，剩余参数在函数中最多只能有一个，并且要作为最后一个参数。</p>
</li>
<li><p>除了上面列举的外，es6函数还引入了new.target元属性。用来判断函数的调用方式，是作为普通函数调用，还是使用new作为构造函数调用。</p>
</li>
</ul>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>es6新引入的默认参数和剩余参数特性都非常好用。推荐使用默认参数代替原来<code>arg1 = arg1 || 默认值</code> 的书写方式， 使用剩余参数代替arguments的能力来操作参数。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/10/es6-箭头函数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yunlong Li">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/favicon.ico">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="icode007">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/10/es6-箭头函数/" itemprop="url">es6 - 箭头函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-10T19:00:00+08:00">
                2017-04-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="es6-箭头函数"><a href="#es6-箭头函数" class="headerlink" title="es6 - 箭头函数"></a>es6 - 箭头函数</h1><p>哇，箭头函数…，听起来好NB，但是如果你知道它是因为使用了<code>=&gt;</code>这样类似箭头的符号 ，所以才叫箭头函数。 瞬间感觉：“呵，这名字起的…”。</p>
<p>es6增加了箭头函数的特性当然不是为了装B，它可以看作是js中函数的一次进化。</p>
<p>我们知道，在js中，函数有着不一样的地位，除了作为普通函数外，它可以用来构造自定义类型，作为对象的方法，通过调用bind方法得到一个新函数。在后三者的使用中，大多数情况下都要用到一个特性 this。</p>
<p>函数中，this是动态绑定的，它的值是根据调用的上下文来确定的，关于函数的4种使用方式，书中都已经有了详细介绍，不再赘述。但是，this在带来强大能力的同时，也增加了编程错误的几率。即使是有经验的开发者，在使用this时，也可能因为疏忽而导致错误，而且，它会让代码更加难以理解。</p>
<p>箭头函数，可以解决上面的问题。</p>
<p>而且，箭头函数可以写的非常的简洁。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="箭头函数简洁的语法"><a href="#箭头函数简洁的语法" class="headerlink" title="箭头函数简洁的语法"></a>箭头函数简洁的语法</h3><p>程序员很懒的，我们热衷于各种脚本语言，语法糖。不就是因为他们能够让开发更有效率，让代码写的更少，更爽吗？箭头函数简化了函数的语法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(arg1, arg2, ...) =&gt; &#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面是一个标准的箭头函数的写法，左边的()中填入函数参数，右边的{}中写入执行语句。</p>
<p>当函数参数只有一个时，()可以省略。 当右边{}中只有单行语句时，{}可以省略。可能有下面这种形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let square = x =&gt; x*x ;</span><br></pre></td></tr></table></figure></p>
<p>它相当于普通函数的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let square = function(x)&#123;</span><br><span class="line">    return x*x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>箭头函数的用法有以下几种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let sum = (num1, num2) =&gt; num1 + num2 ; //作为普通函数使用</span><br><span class="line"></span><br><span class="line">let arr2 = [1,2,3,4].map( item =&gt; item*2 ); //作为回调使用</span><br><span class="line"></span><br><span class="line">(() =&gt; &#123; //语句... &#125;)();                    //作为立即执行的匿名函数使用</span><br></pre></td></tr></table></figure></p>
<h3 id="箭头函数中的this"><a href="#箭头函数中的this" class="headerlink" title="箭头函数中的this"></a>箭头函数中的this</h3><p>箭头函数与普通函数最大的不同就是this，前面已经讲过了，普通函数中this是根据上下文确定的。而在箭头函数中，没有this绑定。</p>
<p>也就是说箭头函数的this的值不再根据调用时上下文确定，而是像普通变量那样根据定义时的作用域链进行查找。如果箭头函数外部是一个非箭头函数，箭头函数内部this的值就与该函数一致。 如果箭头函数外部是全局环境，那么this的值就是全局对象 - window(浏览器环境)或global(node环境)。<br>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var PageHandler = &#123;</span><br><span class="line">    id: &apos;123456&apos;,</span><br><span class="line">    init: function()&#123;</span><br><span class="line">        document.addEventListener(&quot;click&quot;,</span><br><span class="line">            event =&gt; this.doSomething(event.type), false);</span><br><span class="line">    &#125;,</span><br><span class="line">    doSomething: function(type)&#123;</span><br><span class="line">        console.log(&quot;Handling&quot; + type + &quot;for&quot; + this.id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上面这段代码中，由于箭头函数中this与其外部init函数保持一致，因此，this保存的就是PageHandler对象的引用，所以可以调用doSomething方法。</p>
<p>如果使用普通函数代替箭头函数，那么这样使用this会导致错误，因为这时this指向的document对象。 通用的解决方法是在init中保存this的引用<code>var _this = this</code>，然后使用_this代替this。</p>
<h3 id="箭头函数的arguments"><a href="#箭头函数的arguments" class="headerlink" title="箭头函数的arguments"></a>箭头函数的arguments</h3><p>js函数中的arguments给了我们操作函数参数极大的便捷和灵活性。 但是，同this一样，在箭头函数中，没有arguments绑定。</p>
<p>箭头函数中的arguments依然要根据定义时的作用域链进行查找。</p>
<p>虽然，箭头函数中我们无法再使用arguments来操作函数参数， 但是我们可以使用es6中的剩余参数特性来获得同以前arguments同样的效果。比如： </p>
<p><code>let sum = (...rest) =&gt; console.log(rest.length)</code></p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>在使用箭头函数的简写形式时，要注意一点：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let getData = () =&gt; &#123;name: &apos;icode007&apos;, age: 27&#125;; //会报错</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>报错的原因是js把 =&gt;右边对象的{}当成了函数体的{}， 因此，要使用()把对象包裹起来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let getData = () =&gt; (&#123;name: &apos;icode007&apos;, age: 27&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>在箭头函数中，不仅仅是this，arguments没有绑定。<br>同样没有绑定的还有super：es6特性，super指向当前对象的原型对象，相当于Object.getPrototypeOf(this).call(this)</li>
</ul>
<p>new.target: es6特性，用于确定函数的使用方式，如果作为普通函数调用，该值等于undefined，如果作为构造函数调用，该值指向新创建对象实例的构造器。</p>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>箭头函数相比于普通函数有很多优势：代码简洁，性能更好，避免了this的问题等，因此可以大量使用。</p>
<p>就个人感觉来讲，箭头函数更接近于函数的原本的能力。如果仅仅是想封装一段代码，或是作为回调函数使用，而不是用作构造函数，函数绑定等功能。使用箭头函数可以更好。总之，当你在函数中无需使用this时，使用箭头函数可能是更好的选择。</p>
<p>箭头函数也有很多不适合的场景：<br>比如，作为方法使用时，不要使用箭头函数。不要为了过分追求代码的简洁而让函数变得难以阅读和理解等。 知乎这篇文章对箭头函数的一些不适合的场景进行了总结，可以作为参考。</p>
<p><a href="https://zhuanlan.zhihu.com/p/26540168" target="_blank" rel="noopener">什么时候不能使用箭头函数？：知乎</a></p>
<p>可以关注我的专栏<a href="https://segmentfault.com/blog/icode007" target="_blank" rel="noopener">学习es6</a>, 打算对es6知识进行一下系统总结，欢迎共同学习。</p>
<p>参考文献: <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">MDN: 箭头函数</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/09/es6-解构赋值/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yunlong Li">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/favicon.ico">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="icode007">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/09/es6-解构赋值/" itemprop="url">es6 - 解构赋值</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-09T21:00:00+08:00">
                2017-04-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h1><p>解构赋值是一个听起来比较高大上的特性，但按我的理解，它就是一种语法糖。它并没有赋予js更强大的能力，只是让赋值操作更加的灵活，效率。</p>
<p>在es6之前，赋值操作需要=左边是一个变量，右边是一个数据或返回数据的函数等。<br>而解构赋值，是将=右边的结构分解(解构)，然后按照格式给=左边进行赋值，主要分为数组的解构赋值和对象的解构赋值。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>解构赋值的格式为，=左边为解构赋值的语法，=右边为初始化器，即一个对象或数组。</p>
<h3 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h3><p>数组的解构赋值是基于数组位置的，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let [a,b] = [1,2] // 结果a等于1，b等于2</span><br></pre></td></tr></table></figure></p>
<p>也可以通过解构改变变量的值。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let a = 1, b = 2;</span><br><span class="line">[a,b] = [100, 200];</span><br></pre></td></tr></table></figure></p>
<p>当=左边与右边不完全匹配时，未能匹配到的变量会被赋值为undefined,比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let [a,b,c] = [1,2] //a为1，b为2，c为undefined</span><br></pre></td></tr></table></figure></p>
<p>所以可以通过给一些变量指定默认值，以防止这种情况的发生。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let [a,b,c=3] = [1,2] //a==1, b==2, c==3</span><br></pre></td></tr></table></figure></p>
<p>注意：只有当在右边找不到对应的值或值为undefined时，才会使用默认值。</p>
<p>有时候，解构赋值中，你可能只关心一部分数据，这时可以通过占位符只给某些值赋值。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let [a,,,b,,] = [1,2,3,4,5,6,7,8] //a==1 b==4</span><br></pre></td></tr></table></figure></p>
<p>在解构赋值中，通过在变量前加…号，表示生成的变量为一个数组。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let [a,,...b] = [1,2,3,4,5] //a == 1, b==[3,4,5]</span><br></pre></td></tr></table></figure></p>
<p>上面展示的情况都是可以联合使用的,比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let [a,b=8,,..c] = [1,2,3,4,5,6] //a==1 b==2 c=[4,5,6]</span><br></pre></td></tr></table></figure></p>
<h3 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h3><p>对象的解构赋值是基于属性的。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let &#123;name, age&#125; = &#123;</span><br><span class="line">    name: &apos;icode007&apos;,</span><br><span class="line">    age: 27</span><br><span class="line">&#125;</span><br><span class="line">//name == &apos;icode007&apos; age==27</span><br></pre></td></tr></table></figure></p>
<p>与数组的解构赋值一样，对象的解构赋值一样给未能解构的变量赋值undefined，一样可以使用默认值。</p>
<p>当给已存在的变量解构赋值时，注意加()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let name, age;</span><br><span class="line">(&#123;name, age&#125; = &#123;name: &apos;icode007&apos;, age: 27&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这是由于如果不加(),js会把左边看成一个代码块，会报错。 加了()后，整个变成了一个合法的表达式。</p>
<p>在上面的解构赋值中，变量名和对象中的属性名必须相同，只有这样，才能找到对应的要解构赋值的数据。<br>但如果我们想要给数据赋一个不同的名字呢？ 也是有办法的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let &#123;name:myName, age: myAge&#125; = &#123;name: &apos;icode007&apos;, age: 27&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样相应的名字和年龄就被赋值给myName和myAge了。</p>
<p>也可以同时使用默认值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let &#123;name:myName, age: myAge, jog: myJob = &apos;soft Engineer&apos;&#125; = &#123;name: &apos;icode007&apos;, age: 27&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上我们列举的对象的解构赋值的例子都非常的简单，但在实际开发中，JSON数据可能是非常复杂的，这时的解构赋值语法也可能变得复杂。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let node = &#123;</span><br><span class="line">    type: &quot;Identifier&quot;,</span><br><span class="line">    name: &quot;foo&quot;,</span><br><span class="line">    loc: &#123;</span><br><span class="line">        start: &#123;</span><br><span class="line">            line: 1,</span><br><span class="line">            column: 1</span><br><span class="line">        &#125;,</span><br><span class="line">        end: &#123;</span><br><span class="line">            line: 1,</span><br><span class="line">            column: 4</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">let &#123;loc: &#123; start &#125;&#125; = node;</span><br><span class="line">console.log(start.line);</span><br><span class="line">console.log(start.column);</span><br></pre></td></tr></table></figure></p>
<p>注意：每当有:出现在解构赋值中时，:左边的标识符表示要检查的位置，右边表示要赋值的目标，如果右边是{}或[]时，表示要赋值的变量在更深层次结构中。</p>
<p>上面的所有实例，如默认值，变量更名等特性都可能存在于一个解构赋值语句中。并且，数组的解构赋值与对象的解构赋值，也可以混合使用。这为我们从复杂的数据结构中提取相应数据提供了极大的便利。</p>
<h3 id="函数参数的解构"><a href="#函数参数的解构" class="headerlink" title="函数参数的解构"></a>函数参数的解构</h3><p>函数参数的解构功能对于实现多参的函数是非常有用的。<br>比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function setCookie(name, value, options)&#123;</span><br><span class="line">    options = options || &#123;&#125;;</span><br><span class="line">    var secure = option.secure,</span><br><span class="line">        path = option.path,</span><br><span class="line">        domain = option.domain</span><br><span class="line">    ;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setCookie(&apos;type&apos;, &apos;js&apos;, &#123;</span><br><span class="line">    secure: true,</span><br><span class="line">    expires: 60000</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p>
<p>上面的函数是常用的实现多参函数的方式，name, value为必填参数，所有可选参数封装到options中，作为options的属性使用。<br>但上面的函数存在一个问题就是，你只看函数的定义，是无法知道到底可选参数的名称是什么的？你需要阅读函数代码，了解函数才能使用它。</p>
<p>使用函数参数解构则直观很多：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function setCookie(name, value, &#123;secure, path, domain&#125;)&#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用同样的使用方式可以调用这个函数。</p>
<p>但是这种写法有种问题是当只传入name和value参数时，会报错。</p>
<p>更好的写法是使用函数的默认参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function setCookie(name, value, &#123;secure, path = &quot;/&quot;, domain&#125; = &#123;&#125;)&#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li><p>数组的解构赋值中，使用…rest的变量必须放在最后。</p>
</li>
<li><p>与普通的变量的赋值语句一样，解构赋值语句也是有值的，它的值就是=右边的内容。</p>
</li>
</ul>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><ul>
<li>变量交换值<br>在es6之前，交换两个变量的值，需要创建一个中间变量，类似这样<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = 1, b = 2, temp;</span><br><span class="line">temp = a; a = b; b = temp;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>现在只需要一行代码：<br><code>[a,b] = [b,a]</code></p>
<ul>
<li><p>提取json中的一些数据<br>在实际开发中，数据解构是非常复杂的，使用对象属性去层层调用的语法非常不直观，通过解构赋值，可以让代码更加的直观与简洁。</p>
</li>
<li><p>数组的复制<br>数组的解构赋值中，有个小技巧。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1,4,9,55,244];</span><br><span class="line">let [...cloneArray] = arr;</span><br><span class="line">console.log(cloneArray);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这样就实现了数组的浅复制，而在以前，数组的复制都是通过concat()方法来完成。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/09/es6-块级作用域/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yunlong Li">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/favicon.ico">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="icode007">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/09/es6-块级作用域/" itemprop="url">es6 - let const和块级作用域</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-09T19:00:00+08:00">
                2017-04-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="let-const和块级作用域"><a href="#let-const和块级作用域" class="headerlink" title="let const和块级作用域"></a>let const和块级作用域</h1><p>在js高程中，作者强调说js没有块级作用域。<br>然而，这种情况在es6中发生了改变，es6通过在代码块中使用let, const引入了块级作用域的特性。<br>下面是对此特性的介绍。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="es5作用域和变量提升"><a href="#es5作用域和变量提升" class="headerlink" title="es5作用域和变量提升"></a>es5作用域和变量提升</h3><p>首先，在es5中，只有两种作用域，函数作用域和全局作用域。 所有的变量和函数声明都存在于这两种作用域中。</p>
<p>js在执行时，会首先将函数定义和变量声明提升到作用域的顶部，而初始化的代码留在原处，这就是变量提升。 这是js语言与其他语言不同的地方。</p>
<h3 id="块级作用域与let-const"><a href="#块级作用域与let-const" class="headerlink" title="块级作用域与let const"></a>块级作用域与let const</h3><ul>
<li><p>块级作用域简单来说就是使用{}包裹的一段代码，函数，判断，循环，甚至单独的一个{}都可以看作一个块级作用域。<br>在块级作用域内部使用let, const声明的变量，在块作用域外部是不可见的。</p>
</li>
<li><p>准确的说，使用const声明的应该是一个常量，它的值是不可变的，应该在声明时完成初始化。在后面对const声明的变量赋值会导致错误。</p>
</li>
<li><p>在同一个作用域中，使用let或const重复声明变量是不被允许的。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var count = 30;</span><br><span class="line">let count = 20; //这里无论顺序，无论let或const，都会报错。</span><br><span class="line"></span><br><span class="line">//只有这种才不会报错</span><br><span class="line">var count = 30;</span><br><span class="line">var count = 20; //第二个var被忽略，count等于20</span><br></pre></td></tr></table></figure>
</li>
<li><p>let, const声明的变量并不会变量提升。另在，在作用域中，使用二者声明的变量存在一个暂时性死区TDZ，即在声明语句前对变量的访问和使用都会引发引用错误。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(condition)&#123;</span><br><span class="line">    console.log(typeof value);//会报错</span><br><span class="line">    let value = &apos;icode007&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="循环中的块级绑定"><a href="#循环中的块级绑定" class="headerlink" title="循环中的块级绑定"></a>循环中的块级绑定</h3><p>js有一道经典的面试题，即在页面插入10个a标签，点击每个标签时显示相应的序号。或者是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [];</span><br><span class="line">for(var i =0; i&lt;10; i++)&#123;</span><br><span class="line">    arr.push(function()&#123;console.log(i)&#125;);</span><br><span class="line">&#125;</span><br><span class="line">arr[5]();</span><br></pre></td></tr></table></figure></p>
<p>这道题经常用来说明变量的作用域和闭包的相关问题。因为所有的函数引用的都是同一个i，所以都显示10.<br>正确的代码是使用立即执行函数，利用闭包特性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var arr = [];</span><br><span class="line">for(var i=0; i&lt;10; i++)&#123;</span><br><span class="line">    (function(i)&#123;</span><br><span class="line">        arr.push(function()&#123;console.log(i);&#125;);</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line">arr[5]();</span><br></pre></td></tr></table></figure></p>
<p>通过闭包，每个函数调用的实际上是其独有的i。</p>
<p>然而，在es6，有个更好的方案，使用let。只需将第一段代码i声明中var换成let即可。</p>
<p>在for循环中，每次迭代let都会创建一个新的同名变量，并进行初始化，相当于上面使用立即执行函数的行为。在for-in循环和for-of循环中，同样如此。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>const声明的变量是不可变的，其实质是变量所引用的指针不能发生变化，但由于js动态语言的本质，当const声明一个对象时，对对象的改变是允许的。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;name: &apos;icode&apos;&#125;;</span><br><span class="line">obj.name =&apos;thoms&apos;; //不会发生错误</span><br><span class="line">obj = &#123;name: &quot;thoms&quot;&#125; //发生错误</span><br></pre></td></tr></table></figure></p>
<p>在for-in和for-of迭代中使用const与使用let的行为相同，前提是不再代码块中改变它的值，在for循环中，由于i++会改变变量的值，所以会报错。</p>
<p>在之前全局中使用var定义的变量会成为window对象的一个属性，而在全局中使用let, const定义的变量不会成为window对象的属性。 </p>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>推荐的最佳实践是尽量使用let而不是使用var去定义变量，这能让我们代码更加的规范。</p>
<p>更加推荐的做法是一般使用const定义变量，只有在预期变量会发生改动时才使用let来定义。因为大部分变量定义后是无需发生变化的。这种方式能减少代码出错的几率。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/08/es6-引言/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yunlong Li">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/favicon.ico">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="icode007">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/08/es6-引言/" itemprop="url">es6 - 引言</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-08T19:00:00+08:00">
                2017-04-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="学习es6"><a href="#学习es6" class="headerlink" title="学习es6"></a>学习es6</h1><p>es6定稿有两年多的时间了，断断续续通过一些博客，书籍也学到了很多es6知识。可以说，es6给js语言带来了非常大的改进，引进了很多好用的特性。使得js更加的规范，更加的适合现代前端构建大型应用的需要。</p>
<p>虽然学了很多es6的特性，但却总感觉自己的知识不够详细，系统，所以下决心将es6知识整理一番。将各个部分的知识整理成一篇篇博文，以便于自己系统掌握和复习。</p>
<p>整个系列预计有20篇文章左右，每篇文章分为基础语法， 注意事项， 最佳实践三个部分。</p>
<ul>
<li>基础语法 - 主要讲解特性的语法和原理。</li>
<li>注意事项 - 主要讲语法中的一些陷阱和容易忽略的点。</li>
<li>最佳实践 - 主要描述一些开发过程中最常用和恰当的使用方式。</li>
</ul>
<p>由于本人实力有限，所以上面某个部分可能缺失，留待以后完善。</p>
<p>整个系列主要参考了<code>Nicholas zakas</code>的《深入理解es6》，可以看作是对这本书的一个学习总结，也向大家强烈推荐这本书作为es6的学习书籍。</p>
<p>由于es6不能直接运行于浏览器环境，所以通过构建搭建一个es6的运行环境是极好的，这里有个已经搭建好的环境，通过github下载下来，安装依赖即可使用。<code>https://github.com/icode007/es6</code><br><a href="https://github.com/icode007/es6" target="_blank" rel="noopener">构建es6开发环境</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/03/tags- base64图片/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yunlong Li">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/favicon.ico">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="icode007">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/03/tags- base64图片/" itemprop="url">使用base64格式图片制作icon</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-03T12:00:00+08:00">
                2017-04-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="使用base64格式图片制作icon"><a href="#使用base64格式图片制作icon" class="headerlink" title="使用base64格式图片制作icon"></a>使用base64格式图片制作icon</h1><h2 id="什么是base64格式的图片？"><a href="#什么是base64格式的图片？" class="headerlink" title="什么是base64格式的图片？"></a>什么是base64格式的图片？</h2><p>所谓base64格式的图片就是将一副图片信息编码成一串字符串，解析该字符串，即可显示图片。<br>也就是说，以字符串的形式存储图片信息。</p>
<h2 id="base64格式的图片解决了什么问题？"><a href="#base64格式的图片解决了什么问题？" class="headerlink" title="base64格式的图片解决了什么问题？"></a>base64格式的图片解决了什么问题？</h2><p>在一张网页中，是有非常多的图片信息的。而每一张图片，都需要一个http请求。累积下来，时间成本是非常高的，所以才有了cssSprite。</p>
<p>而在一些无法或不必要使用雪碧图的情况下，可以使用base64格式的图片，这样，图片信息保存在html或css中，减少了http请求，提升了加载速率。</p>
<h2 id="使用base64格式图片的优缺点？"><a href="#使用base64格式图片的优缺点？" class="headerlink" title="使用base64格式图片的优缺点？"></a>使用base64格式图片的优缺点？</h2><ul>
<li>优点</li>
</ul>
<ol>
<li>就像上面说的，它主要目的就是减少http请求。</li>
<li>写控件的时候使用它，这样控件只需一个js文件来完成，别人使用也只需要下载一个js文件。<br><br></li>
</ol>
<ul>
<li>缺点</li>
</ul>
<ol>
<li><p>兼容性问题，IE8以下不支持data url，IE8支持，但是有大小限制。</p>
</li>
<li><p>如果把base64编码到html/css中，会造成后二者解析速率变慢。<br>由于二者在解析中会阻塞，所有造成整个网页加载速率变慢。<br>而外链图片可以在渲染完后继续加载，不会造成阻塞。</p>
</li>
<li><p>base64格式的图片普遍比原文件大1/3。</p>
</li>
<li><p>代码会很难看，编辑器卡，无法直接在编辑器中查看图片。 </p>
</li>
</ol>
<h2 id="什么情况使用该格式的图片，怎么用？"><a href="#什么情况使用该格式的图片，怎么用？" class="headerlink" title="什么情况使用该格式的图片，怎么用？"></a>什么情况使用该格式的图片，怎么用？</h2><p>综合上面的优缺点，当图片足够小（几KB）或因为用处特殊性无法制成雪碧图，又使用率很高，基本上不会被更新，可以使用base64。</p>
<p>比如，非常小的网站的背景图等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">background-image: url(&quot;data:image/png;base64,iVBORw0KGgo=...&quot;);</span><br><span class="line">//在css中使用</span><br><span class="line">&lt;img src=&quot;data:image/png;base64,iVBORw0KGgo=...&quot; /&gt;</span><br><span class="line">//在html中使用</span><br></pre></td></tr></table></figure>
<p>可以使用图片在线转换工具进行转换。<br>还可以使用浏览器，打开chrome浏览器，打开一个新页面，将图片拖入页面，打开控制台–source–图片，就可以显示该图片的base64编码。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/27/tags- css 响应式项目/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yunlong Li">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/favicon.ico">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="icode007">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/27/tags- css 响应式项目/" itemprop="url">使用媒体查询构建响应式网站</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-27T22:17:48+08:00">
                2017-03-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="使用媒体查询构建响应式网站"><a href="#使用媒体查询构建响应式网站" class="headerlink" title="使用媒体查询构建响应式网站"></a>使用媒体查询构建响应式网站</h1><p>响应式网站的概念现在很流行，其兴起来源于手机，平板等各种屏幕的智能终端的流行。 为了使网站代码适用各种屏幕（台式机，笔记本，平板，大屏手机，手机等），所有有了响应式网站的概念。</p>
<p>响应式网站的实现主要依赖于：弹性网格，弹性图片，媒体查询这3大技术。</p>
<h2 id="使用媒体查询前元数据的设置"><a href="#使用媒体查询前元数据的设置" class="headerlink" title="使用媒体查询前元数据的设置"></a>使用媒体查询前元数据的设置</h2><pre><code>css3设置meta标签为适应响应式设置做准备
</code></pre><p><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0 user-scalable=no&quot;&gt;</code></p>
<pre><code>这段代码参数的解释：
width=device-width 设置宽度等于当前设备宽度
initial-scale 设置初始缩放比例为（默认值）1.0
maximum-scale/minimum-scale 最大/最小缩放比例为1.0
user-scalable=no 不允许用户缩放
</code></pre><h2 id="解决IE8及以下浏览器兼容问题"><a href="#解决IE8及以下浏览器兼容问题" class="headerlink" title="解决IE8及以下浏览器兼容问题"></a>解决IE8及以下浏览器兼容问题</h2><pre><code>由于ie8及以下不支持h5,也不支持css3，所以使用条件注释及兼容性插件
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--[if lt IE 9]&gt;</span><br><span class="line">&lt;script src=&quot;...&quot;&gt;&lt;/script&gt; //使用html5shiv.js使得低版本兼容h5</span><br><span class="line">&lt;script src=&quot;...&quot;&gt;&lt;/script&gt; //使用respond.min.js兼容媒体查询</span><br><span class="line">&lt;![endif]--&gt;</span><br></pre></td></tr></table></figure>
<h2 id="设置IE的渲染模式为使用最新模式渲染页面"><a href="#设置IE的渲染模式为使用最新模式渲染页面" class="headerlink" title="设置IE的渲染模式为使用最新模式渲染页面"></a>设置IE的渲染模式为使用最新模式渲染页面</h2><p><code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</code></p>
<h2 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h2><pre><code>媒体查询的两种使用方法
1. 使用link标签
</code></pre><p><code>&lt;link rel=&quot;style-sheet&quot; type=&quot;text/css&quot; media=&quot;screen and (orientation:portrait) href=&quot;style.css&quot;&gt;</code></p>
<pre><code>其中media双引号内部内容为媒体查询条件，下面部分会详细介绍媒体查询语法。
2. 在css样式中使用媒体查询(使用@media)，花括号中为css代码
</code></pre><p><code>@media screen and (max-width:960px){}</code></p>
<h2 id="媒体查询语法"><a href="#媒体查询语法" class="headerlink" title="媒体查询语法"></a>媒体查询语法</h2><p>媒体查询语法由一个可选的媒体类型和一个或多个表达式组成，当表达式链为真时，应用对应的css规则。<br>    如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@media screen and (max-width:960px)&#123;&#125;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; meida=&quot;screen and (max-width:960px)&quot; href=&quot;example.css&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="媒体类型"><a href="#媒体类型" class="headerlink" title="媒体类型"></a>媒体类型</h3><p>媒体类型一般是screen，还有all，print, tv, handheld等，也可以不写，不写的话为默认值all。</p>
<p>注意： 当使用not或only操作符，媒体类型要写。</p>
<h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p>表达式是使用()括起来的内容。括号内为媒体特征，注意：如果设备浏览器上不包含该特征，那么表达式一般返回假，比如(smfy:4),谁认识这是啥呀？返回假，下面是一些媒体特征。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(color)</span><br><span class="line">(min-color:4)</span><br><span class="line">(max-device-width:960px)</span><br><span class="line">(orientation:portrait)</span><br></pre></td></tr></table></figure></p>
<p>更多内容参照 <a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Media_queries#黑白（monochrome）" target="_blank" rel="noopener">MDN媒体查询</a>。</p>
<h3 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h3><p>媒体查询条件可以使用逻辑操作符号，and , not ,only 还有逗号，<br>and用于将多个条件连成一个，只有当都为真时为真<br><code>(min-width:960px) and (max-width:1440px)</code></p>
<p>not用于对媒体查询结果取反，not仅能用于整个查询，<br>only只有在匹配成功的情况下才用到，用于防止样式在老式浏览器中应用。<br>    如果使用了not或only，比如指明媒体类型<br>    逗号，表示或<br>更详尽的内容参照<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Media_queries#黑白（monochrome）" target="_blank" rel="noopener">MDN媒体查询</a></p>
<hr>
<p>总之，媒体查询就是css的一些新的语法规则，必要时参考规则进行使用。<br>其他参考： <a href="http://www.51xuediannao.com/html+css/htmlcssjq/css3_media.html" target="_blank" rel="noopener">css3媒体查询用法总结</a>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/22/tags- css/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yunlong Li">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/favicon.ico">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="icode007">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/22/tags- css/" itemprop="url">css清除浮动</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-22T12:00:00+08:00">
                2017-03-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="css清除浮动"><a href="#css清除浮动" class="headerlink" title="css清除浮动"></a>css清除浮动</h1><p>css中的浮动真是令人又爱又恨，因为通过它可以实现一些布局，但是浮动又会带来很多的麻烦。</p>
<p>使用flex同样可以代替浮动实现布局，但是ie8,9 不支持。</p>
<h2 id="目前通用的清除浮动的方法"><a href="#目前通用的清除浮动的方法" class="headerlink" title="目前通用的清除浮动的方法"></a>目前通用的清除浮动的方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.clearfix:after&#123;</span><br><span class="line">    content: &apos;.&apos;;</span><br><span class="line">    display: block;</span><br><span class="line">    height: 0;</span><br><span class="line">    clear: both;</span><br><span class="line">    visibility: hidden;</span><br><span class="line">&#125;</span><br><span class="line">.clearfix&#123;</span><br><span class="line">    zoom: 1;//为了兼容IE6，IE7，不要求的话可以不写</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="更优雅的方法"><a href="#更优雅的方法" class="headerlink" title="更优雅的方法"></a>更优雅的方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">.clearfix:bofore,这行代码对于清除浮动不是必须的，这样写是可以防止顶部的空白崩溃，比如防止该盒子的margin-top与上一个盒子的margin-bottom发生的margin值的叠加。</span><br><span class="line">*/</span><br><span class="line">.clearfix:before,</span><br><span class="line">.clearfix:after&#123;</span><br><span class="line">    content: &apos; &apos;;</span><br><span class="line">    display: table;</span><br><span class="line">&#125;</span><br><span class="line">.clearfix:after&#123;</span><br><span class="line">    clear: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他清除浮动的方法1"><a href="#其他清除浮动的方法1" class="headerlink" title="其他清除浮动的方法1"></a>其他清除浮动的方法1</h2><p>以前的代码中，清除浮动比较常用的方法是在浮动元素的容器元素后添加代码：<br><code>&lt;div style=&quot;clear:both&quot;&gt;&lt;/div&gt;</code></p>
<pre><code>这种方法的弊端是违背了提倡的结构与表现分离原则。后期代码维护也较麻烦。
</code></pre><h2 id="其他清除浮动方法2"><a href="#其他清除浮动方法2" class="headerlink" title="其他清除浮动方法2"></a>其他清除浮动方法2</h2><p>清除浮动的第2种方法给容器添加overflow属性，如<br><code>overflow:auto</code> 或 <code>overflow:hidden</code></p>
<pre><code>当添加了这样的overflow属性后，浮动元素又会回到了容器元素中。达到清理浮动的效果。
</code></pre><h2 id="其他清除浮动方法3"><a href="#其他清除浮动方法3" class="headerlink" title="其他清除浮动方法3"></a>其他清除浮动方法3</h2><p>清除浮动的第3种方法是给容器元素设置float属性，让容器元素也浮动起来。但是，这样方法并没有彻底的解决问题。后续元素要一直浮动下去。</p>
<h2 id="css中的BFC"><a href="#css中的BFC" class="headerlink" title="css中的BFC"></a>css中的BFC</h2><p>所谓bfc就是块级格式化上下文，更详细的bfc的介绍<br><a href="http://web.jobbole.com/84808/" target="_blank" rel="noopener">什么是BFC</a></p>
<pre><code>bfc和清除浮动的关系可以理解为：

属性值和方法只要触发了bfc，就可以清除浮动。
比如:float(不是none),overflow(not visible)
,display(table-caption,table-cell,inline-block),position(fixed,absolute)等。上述清除浮动的方法都可以理解为触发为了bfc。
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/11/tags- html 响应式图片/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yunlong Li">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/favicon.ico">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="icode007">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/11/tags- html 响应式图片/" itemprop="url">响应式图片解决方案</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-11T12:00:00+08:00">
                2017-03-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="响应式图片解决方案"><a href="#响应式图片解决方案" class="headerlink" title="响应式图片解决方案"></a>响应式图片解决方案</h1><h2 id="使用响应式图片技术的原因"><a href="#使用响应式图片技术的原因" class="headerlink" title="使用响应式图片技术的原因"></a>使用响应式图片技术的原因</h2><p>随着响应式开发的流行，一套开发可以适应pc，平板，手机等多种终端设备，但是比如当我们在手机上依然使用pc端适用的高分辨率图的话，带来的流量的消耗是很多的，而且图片在小屏幕上缩小显示，会变得不清晰。如果使用小图的话，在高分辨率设备上又变得模糊。</p>
<p>另外，苹果的ritina屏幕的像素比为2，这样一张图片在像素比为1的屏幕上正常显示，在ritina设备上显示效果也会不好。<br>所以我们需要一种能够根据设备切换显示图片的技术。</p>
<p><a href="http://www.cnblogs.com/qiuzhimutou/p/6115385.html" target="_blank" rel="noopener">响应式图片</a><br><a href="http://www.jianshu.com/p/235ef450f5e9" target="_blank" rel="noopener">响应式图片解决方案</a></p>
<h2 id="结合使用picture标签和picturefill"><a href="#结合使用picture标签和picturefill" class="headerlink" title="结合使用picture标签和picturefill"></a>结合使用picture标签和picturefill</h2><p>使用srcset和sizes我感觉并不是一个好的设计，麻烦不说，也不够直观。下面介绍picture标签<br>picture标签内由多个source标签和一个img标签组成。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;picture&gt;</span><br><span class="line">	&lt;source meida=&quot;(max-width:750px)&quot; srcset=&quot;img/smaller.jpg&quot;&gt;</span><br><span class="line">	&lt;source meida=&quot;(orientation:landscope)&quot; srcset=&quot;img/smaller.jpg&quot;&gt;</span><br><span class="line">	&lt;source srcset=&quot;default.jpg&quot;&gt;</span><br><span class="line">	&lt;img src=&quot;default.jpg&quot; alt=&quot;&quot;&gt;</span><br><span class="line">&lt;/picture&gt;</span><br></pre></td></tr></table></figure></p>
<p>浏览器会遍历picture中的项，然后将符合媒体查询的项的srcset代入img中。达到设置srcset的目的。source里除了可以使用媒体查询来匹配外，还可以使用type属性来匹配图片的格式等。<br>更详细的picture标签介绍<br><a href="http://www.w3cplus.com/html5/quick-tip-how-to-use-html5-picture-for-responsive-images.html" target="_blank" rel="noopener">HTML5 picture</a></p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/picture" target="_blank" rel="noopener">MDN picture</a></p>
<h2 id="结合使用srcset和sizes属性"><a href="#结合使用srcset和sizes属性" class="headerlink" title="结合使用srcset和sizes属性"></a>结合使用srcset和sizes属性</h2><p>实现响应式图片的另一个方法是使用img图片的srcset属性。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;img/480.png&quot; srcset=&quot;img/480.png 480w, img/800.png 800w, img/1600.png 1600w&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<p>srcset属性的值是，分隔的字符串列表，其中480w中的w表示图片宽度。这样写之后浏览器会根据算法自动选择要加载的图片，当然，如果浏览器判断已经加载了高精度的图片，会自动选用高精度的图片。</p>
<p>上面的属性看起来并不那么好，比如当我们设置图片的宽度为视口宽度的50%，浏览器依然根据图片的宽度和视口的宽度选择图片，而我们需要的是根据图片的宽度和实际图片的容器的宽度来选择图片（比如视口810像素，选择加载800.png,而实际上图片容器只有405像素，我们需要的是460png）。</p>
<p>我们需要更精确的控制图片的显示，这就需要sizes属性。<br>sizes属性的默认值为100vw(viewportwidth)。即图片按100%视口宽度显示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;img/480.png&quot; srcset=&quot;img/480.png 480w, img/800.png 800w, img/1600.png 1600w&quot;  sizes=&quot;30vw&quot;&gt;</span><br><span class="line">//表示根据30%视口宽度进行选择</span><br><span class="line">	</span><br><span class="line">&lt;img src=&quot;img/480.png&quot; srcset=&quot;img/480.png 480w, img/800.png 800w, img/1600.png 1600w&quot;     sizes=&quot;(min-width:800px) 800px, 50vw&quot;&gt;</span><br><span class="line">//表示大于等于800px时，预估需要图片尺寸是800px,其他情况下为50%视口宽度。</span><br><span class="line">&lt;img src=&quot;img/480.png&quot; srcset=&quot;img/480.png 480w, img/800.png 800w, img/1600.png 1600w&quot;  sizes=&quot;(min-width:800px) calc(100vw - 30em), 50vw&quot;&gt; </span><br><span class="line">//表示大于等于800px自动选用计算出的图片，其他情况下根据50%视口宽度选择。</span><br></pre></td></tr></table></figure></p>
<p>sizes的值是一个字符串列表，每一项是有媒体查询+空格+图片预设宽度设置组成。媒体查询可省略，表示应用于所有。<br>总之，结合使用srcset和sizes可以切换和设置图片及图片尺寸。</p>
<h2 id="通过cookie和服务器"><a href="#通过cookie和服务器" class="headerlink" title="通过cookie和服务器"></a>通过cookie和服务器</h2><p>将终端的屏幕信息写入cookie，然后根据cookie在服务器选择发送的图片。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/05/tags- 前端工具 Markdown/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yunlong Li">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/favicon.ico">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="icode007">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/05/tags- 前端工具 Markdown/" itemprop="url">Markdown简明教程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-05T12:00:00+08:00">
                2017-03-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#Markdown教程</p>
<p>##Markdown简介</p>
<p>按照我的理解呢，所谓markdown其实是类似于txt或word的一种文本格式，保存为以.md结尾的文件。 比如：txt极其轻量级，但是很难格式化写作，word带有格式，功能强大，但是编辑器臃肿庞大，与轻量级相去甚远。</p>
<p>总之，markdown就是一种使用几种特殊符号来表达格式的，比txt强大不少的，比html轻量不少的，易于学习的，很容易转换为html格式输出的，特殊格式的文本，在github，一些博客网站上广泛应用。</p>
<p>##Markdown语法</p>
<p>###标题</p>
<p>使用1-6个#来表示标题，类似于html中标题标签（h1~h6）。#号和标题间最好加空格，这是标准写法。<br>    # 一级标题<br>    ## 二级标题<br>    。。。<br>    ######六级标题</p>
<p>###列表<br>使用类似1. 2. 3.这样的前缀来表示列表。比如：</p>
<ol>
<li>apple</li>
<li>banana</li>
<li>orange</li>
</ol>
<p>使用-或*号来表示无序列表，比如:</p>
<ul>
<li>apple</li>
<li>banana</li>
<li>orange</li>
</ul>
<p>###引用<br>使用&gt;来表示引用,比如：</p>
<blockquote>
<p>黄河之水天上来，奔流到海不复回。</p>
</blockquote>
<p>###图片和链接<br>    使用<a href=""></a>来表示链接，使用<img src="" alt="">来表示图片。 其中[]中分别为链接显示文本或图片说明，()中为链接或图片地址。比如：</p>
<p><a href="http://www.baidu.com" target="_blank" rel="noopener">百度</a></p>
<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1505899069056&amp;di=f76a3fd8164e14682e48585620658641&amp;imgtype=0&amp;src=http%3A%2F%2Fwww.pp3.cn%2Fuploads%2F1304%2F188.jpg" alt="图片说明"></p>
<p>###粗体和斜体<br>使用<em>和**分别表示斜体和粗体，比如：
</em>斜体<em><br><em>*粗体</em></em></p>
<p>###分割线<br>使用<em>*</em>来表示分割线</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>使用<code>符号来引用代码(tab上面的键),比如:</code>function foo(){    console.log(‘hello’);}`</p>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>表格使用|管道号来表示，第一行为表头，使用|分隔，第3行往后为内容，也使用|来分隔。</p>
<p>第二行表示表格的对齐方式。-表示默认的做对齐，-：表示右对齐。：-：表示居中对齐。比如：</p>
<p><code>|name|zhangsan|xiaohua|pangpang|
|-:|:-|:-:|
|id|3456|1234|7986|
|age|16|13|17|</code></p>
<table>
<thead>
<tr>
<th>name</th>
<th style="text-align:left">zhangsan</th>
<th style="text-align:center">xiaohua</th>
<th style="text-align:right">pangpang</th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td style="text-align:left">3456</td>
<td style="text-align:center">1234</td>
<td style="text-align:right">7986</td>
</tr>
<tr>
<td>age</td>
<td style="text-align:left">16</td>
<td style="text-align:center">13</td>
<td style="text-align:right">17</td>
</tr>
</tbody>
</table>
<p>###markdown兼容html<br>在我看来，markdown就是一种轻量级的，使用符号代替标签的html，一些使用md无法表示的，可以直接使用html标签来书写。md编辑器足够智能来识别html。同时，所有的md格式也可以转化为html文档输出。当然有些标签书写时时需要注意的。可以参考  <a href="http://wowubuntu.com/markdown/#blockquote" target="_blank" rel="noopener">Markdown语法说明</a>.</p>
<p>###转义字符<br>使用\来实现转义字符。比如#, *等。写到这里，突然有个问题，有了html，为什么还要markdown。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/favicon.ico"
                alt="Yunlong Li" />
            
              <p class="site-author-name" itemprop="name">Yunlong Li</p>
              <p class="site-description motion-element" itemprop="description">web前端,html,css,javascript,vue</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/icode007" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:li2467li@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2016 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yunlong Li</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
